<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin学习（二）：控制语句详解篇]]></title>
    <url>%2F2019%2F08%2F14%2FKotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言通过上一篇的学习，我们对kotlin已经掌握了函数的定义，基本数据类型，null安全设计，类型检测及自动转换和Kotlin的区间表达式，如果您还有任何不明白的地方，请跳转至我的上一篇博客：《Kotlin学习（一）：我TM谢谢你！(基础语法篇)》对于kotlin，这只是最基础的入门讲解，也希望大家能够跟我一样逐渐适应kotlin的美，我们一起进步，我相信通过一段时间的学习，我也可以像大家分享一些kotlin的语法糖以及更深入的使用。我的博客（Power） kotlin控制语句详解 条件控制语句：if 语句、when 语句 循环控制语句：for 循环、while与do…while 循环 返回和跳转语句：return、 break、 continue 1. if语句kotlin的if表达式其实和java是非常类似的，唯一不同的地方在于kotlin可以把表达式的结果赋值给变量，类似于java的三元运算符，我们可以直接实现。1234567891011121314// 传统用法var max = a if (a &lt; b) max = b// 使用 else var max: Intif (a &gt; b) &#123; max = a&#125; else &#123; max = b&#125; // 作为表达式val max = if (a &gt; b) a else b 举例：123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; var x = 0 if(x&gt;0)&#123; println("x 大于 0") &#125;else if(x==0)&#123; println("x 等于 0") &#125;else&#123; println("x 小于 0") &#125; var a = 1 var b = 2 val c = if (a&gt;=b) a else b println("c 的值为 $c")&#125;//输出结果为：x 等于 0c 的值为 2 2. when表达式when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。我们看下例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344//在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // 注意这个块,else 相当于 switch 的 default print("x 不是 1 ，也不是 2") &#125;&#125;//如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔when (x) &#123; 0, 1 -&gt; print("x == 0 or x == 1") else -&gt; print("otherwise")&#125;//我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125;//另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125;//when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125;//when 中使用 in 运算符来判断集合内是否包含某实例fun main(args: Array&lt;String&gt;) &#123; val items = setOf("apple", "banana", "kiwi") when &#123; "orange" in items -&gt; println("juicy") "apple" in items -&gt; println("apple is fine too") &#125;&#125; 举例：123456789101112131415161718192021222324fun main(args: Array&lt;String&gt;) &#123; var x = 0 when (x) &#123; 0, 1 -&gt; println("x == 0 or x == 1") else -&gt; println("otherwise") &#125; when (x) &#123; 1 -&gt; println("x == 1") 2 -&gt; println("x == 2") else -&gt; &#123; // 注意这个块 println("x 不是 1 ，也不是 2") &#125; &#125; when (x) &#123; in 0..10 -&gt; println("x 在该区间范围内") else -&gt; println("x 不在该区间范围内") &#125;&#125;//输出结果：x == 0 or x == 1x 不是 1 ，也不是 2x 在该区间范围内 3. for循环 for 循环可以对任何提供迭代器（iterator）的对象进行遍历 kotlin 废除了 java 的 for(int i = 0; i &lt; list.size(); i++)规则，新增了其他的规则，来满足对数组或集合的遍历 循环数组会编译成优化的实现而不会创建额外对象，或者你可以用库函数 withIndex：123456789101112131415//for循环可以对任何提供迭代器（iterator）的对象进行遍历for (item in collection) print(item)for (item: Int in ints) &#123; // ……&#125;//如果你想要通过索引遍历一个数组或者一个 listfor (i in array.indices) &#123; print(array[i])&#125;//循环数组会编译成优化的实现而不会创建额外对象，或者你可以用库函数 withIndex：for ((index, value) in array.withIndex()) &#123; println("the element at $index is $value")&#125; 举例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 循环5次，且步长为1的递增for (i in 0 until 5)&#123; print("i =&gt; $i \t")&#125;// 循环5次，且步长为1的递减for (i in 15 downTo 11)&#123; print("i =&gt; $i \t")&#125;print("使用 符号`..`的打印结果\n")for (i in 20 .. 25)&#123; print("i =&gt; $i \t")&#125;print("使用until的打印结果\n")for (i in 20 until 25)&#123; print("i =&gt; $i \t")&#125;//输出结果：使用 符号`..`的打印结果i =&gt; 20 i =&gt; 21 i =&gt; 22 i =&gt; 23 i =&gt; 24 i =&gt; 25 使用until的打印结果i =&gt; 20 i =&gt; 21 i =&gt; 22 i =&gt; 23 i =&gt; 24 //使用数组的indices属性遍历var arrayListTwo = arrayOf(1,3,5,7,9)for (i in arrayListTwo.indices)&#123; println("arrayListTwo[$i] =&gt; " + arrayListTwo[i])&#125;//输出结果：arrayListTwo[0] =&gt; 1arrayListTwo[1] =&gt; 3arrayListTwo[2] =&gt; 5arrayListTwo[3] =&gt; 7arrayListTwo[4] =&gt; 9//使用数组的withIndex()方法遍历var arrayListTwo = arrayOf(1,3,5,7,9)for ((index,value) in arrayListTwo.withIndex())&#123; println("index =&gt; $index \t value =&gt; $value")&#125;//输出结果：index =&gt; 0 value =&gt; 1index =&gt; 1 value =&gt; 3index =&gt; 2 value =&gt; 5index =&gt; 3 value =&gt; 7index =&gt; 4 value =&gt; 9 4. while， do…while语句kotlin的while语句和java的while语句一样，下面我们直接举栗：123456789101112131415161718192021222324252627282930313233343536373839404142var num = 5var count = 1while (num &lt; 10)&#123; println("num =&gt; $num") println("循环了$count 次") count++ num++&#125;//输出结果：num =&gt; 5循环了1 次num =&gt; 6循环了2 次num =&gt; 7循环了3 次num =&gt; 8循环了4 次num =&gt; 9循环了5 次//do...while语句var num = 5var count = 1do &#123; println("num =&gt; $num") println("循环了$count 次") count++ num++&#125;while (num &lt; 10)//输出结果：num =&gt; 5循环了1 次num =&gt; 6循环了2 次num =&gt; 7循环了3 次num =&gt; 8循环了4 次num =&gt; 9循环了5 次// *注* : do&#123;...&#125;while(exp)与while(exp)&#123;...&#125;最大的区别是do&#123;...&#125;while(exp)最少执行一次，这点也是和Java相同的 5. 返回和跳转语句return、break、continue的用法和java是一样的， eturn。默认从最直接包围它的函数或者匿名函数返回 break。终止最直接包围它的循环 continue。继续下一次最直接包围它的循环我们直接看代码吧： 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) &#123; if (i==3) continue // i 为 3 时跳过当前循环，继续下一次循环 println(i) if (i&gt;5) break // i 为 6 时 跳出循环 &#125;&#125;//输出结果为：1 2 4 5 6fun returnExample()&#123; var str: String = "" if (str.isBlank())&#123; println("我退出了该方法") return &#125;&#125;//输出结果为：我退出了该方法 Break 和 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习（一）：我TM谢谢你！(基础语法篇)]]></title>
    <url>%2F2019%2F07%2F30%2FKotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%88%91TM%E8%B0%A2%E8%B0%A2%E4%BD%A0%EF%BC%81(%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言自从2017年Google定义Kotlin为Android开发的官方语言，瞬间掀起了学习大潮，各种学习博客如雨后春笋般攻击我这颗弱小而又无助的小心脏！是你们，是的，就是因为你们使我变得越来越强大，我TM替我日益稀疏的头发谢谢各位学霸！！！所以，搞起来吧！开启我们从乌黑亮丽到寸草不生的kotlin学习之旅！我的博客（Power） 作为Android开发水军中的一员，其实很早就简单看了语法，其中的优缺点这里就不再过多陈述，不清楚或想详细了解的请自行社会你度十三娘，鉴于大家如果能有幸看见这边文章，想必对我们吃饭的家伙熟悉程度应该不亚于我了，所以对于Android studio的环境配置这里小弟就不再卖弄风骚了，毕竟在座的各位都是学霸，VIP中P…这里在开头也为大家分享一些大牛关于学习Kotlin的链接，有助于大家在吃百家饭的时候，不容易养成挑食的小毛病。本系列均踩在各位巨人的肩膀上总结而成！请各位看官轻喷…Kotlin语言中国Kotlin-菜鸟教程Kotlin入门到进阶玩Android-kotlin文章 Kotlin基础语法 函数的定义 函数使用关键字 fun，参数格式为：参数 : 类型 1234// sum:函数名 a,b参数名，Int参数类型fun sum(a: Int, b: Int): Int &#123;// :后边Int为返回值类型 return a + b&#125; 这里需要注意如果是public则必须声明返回值类型，如果是无返回值的函数（:Unit）则可以省略。 12345678910fun unitFun() : Unit&#123; println("我是返回值为Unit的函数，Unit可省略") return // return Unit 可省略 // 或者 return 可省略&#125;//等价于fun unitFun()&#123; println("我是返回值为Unit的函数，Unit可省略")&#125; 可变长参数函数，用 vararg 关键字进行标识 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; 常量与变量 变量：var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 12var x: Int = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 常量：val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 1234val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值 Kotlin基本数据类型基础数据类型包含有： 数值类型 字符类型 字符串类型 布尔类型 数组类型 数值类型（Numbers） Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等 不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Byte 8 Short 16 Int 32 Long 64 Float 32 Double 64 字符类型（Characters） 和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’ 123456val ch :Char = 1; // 错误示范val ch :Char = '1'; // 正确示范// 将字符类型转换成数字val ch :Char = '8';val a :Int = ch.toInt() 字符串类型（Strings） 和 Java 一样，String 是不可变的。 12345678910111213141516171819202122//1.方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：for (c in str) &#123; println(c)&#125;//2.支持三个引号 """ 扩起来的字符串，支持多行字符串，比如：fun main(args: Array&lt;String&gt;) &#123; val text = """ 多行字符串 多行字符串 """ println(text) // 输出有一些前置空格&#125;//3.String 可以通过 trimMargin() 方法来删除多余的空白:fun main(args: Array&lt;String&gt;) &#123; val text = """ |多行字符串 |菜鸟教程 |多行字符串 |Runoob """.trimMargin() println(text) // 前置空格删除了&#125; 字符串模板：即在字符串内通过一些小段代码求值并把结果合并到字符串中。模板表达式以美元符（$）开头 1234567891011fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = "i = $i" println(s) // 求值结果为 "i = 10"&#125;//用花括号扩起来的任意表达式:fun main(args: Array&lt;String&gt;) &#123; val s = "runoob" val str = "$s.length is $&#123;s.length&#125;" println(str) // 求值结果为 "runoob.length is 6"&#125; 布尔类型（Boolean） 布尔用 Boolean 类型表示，它有两个值：true 和 false。 内置的布尔运算有： 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组类型（Arrays） 数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。 123456789fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant） 除了类Array，还有ByteArray, ShortArray, IntArray等等，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样： 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] Kotlin的Null安全设计 声明可为null参数及null判断处理 类型后面加 ？ 即表示可为null 进行判null处理时有两种方式： 第一种就是字段后加 !! 表示像java一样抛出null异常 第二种就是字段后加 ? 表示不作处理，可以返回null 第三种就是字段后加 ?: 表示字段为null时返回的值 当然， if/else也是可以的，在使用if判null后，可自动转换为非null变量 12345678//类型后面加?表示可为空var age: String? = "23" //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 函数中使用可null类型 当一个函数/方法有返回值时，如果方法中的代码使用?.去返回一个值，那么方法的返回值的类型后面也要加上 ? 符号 12345fun funNullMethod() : Int? &#123; val str : String? = "123456" return str?.length&#125;//输出：6 Kotlin的类型检测及自动类型转换 我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字) 12345678910111213141516171819202122232425262728fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125;//或者fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125;//甚至还可以fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; Kotlin的区间表达式 区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125;//实测示例fun main(args: Array&lt;String&gt;) &#123; print("循环输出：") for (i in 1..4) print(i) // 输出“1234” println("\n----------------") print("设置步长：") for (i in 1..4 step 2) print(i) // 输出“13” println("\n----------------") print("使用 downTo：") for (i in 4 downTo 1 step 2) print(i) // 输出“42” println("\n----------------") print("使用 until：") // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println("\n----------------")&#125; /* 输出结果： 循环输出：1234 ---------------- 设置步长：13 ---------------- 使用 downTo：42 ---------------- 使用 until：123 ---------------- */]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android三种动画详解]]></title>
    <url>%2F2019%2F01%2F08%2FAndroid%E4%B8%89%E7%A7%8D%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言自尊，自律，自强，自爱。–Power 一直以来自己对Android的动画一知半解，所以决定写这篇文章来详细系统的学习Android的三种动画，即 View Animation（视图动画） Drawable Animation（帧动画） Property Animation（属性动画） 正文1.View Animation（视图动画）1.1 View动画的概述及种类视图动画的作用对象是View，支持四种动画效果，分别是平移动画，缩放动画，旋转动画，透明度动画。譬如，我们可以对TextView设置其文本的移动，旋转，缩放，透明。 视图动画可以通过XML或通过代码动态创建，对于视图动画建议使用XML文件定义，因为它具有更高的可读性，可重用性。 下面我们来分别看一下View动画的四种效果： 平移动画（TranslateAnimation） 缩放动画（ScaleAnimation） 旋转动画（RotateAnimation） 透明度动画（AlphaAnimation） view动画的四种变换我们通过效果图已基本了解，下面我们通过表格系统的了解一下： 名称 标签 子类 效果 平移动画 &lt; translate &gt; TranslateAnimation 移动View 缩放动画 &lt; scale &gt; ScaleAnimation 方法或缩小View 旋转动画 &lt; rotate &gt; RotateAnimation 旋转view 透明度动画 &lt; alpha &gt; AlphaAnimation 改变View的透明度 要使用View动画，首先要创建XML文件，我们需要在res下新建anim文件夹，接着在anim下创建animation resource file的xml文件，我们举例为view_anim.xml 我们通过xml文件来了解它们各自的语法： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--平移动画标签--&gt; &lt;translate android:fromXDelta="0%p" android:toXDelta="20%p" android:fromYDelta="0%p" android:toYDelta="20%p" android:duration="4000"/&gt; &lt;!--缩放动画标签--&gt; &lt;scale android:fromXScale="1.0" android:toXScale="0.2" android:fromYScale="1.0" android:toYScale="0.2" android:pivotX="50%" android:pivotY="50%" android:duration="4000"/&gt; &lt;!--旋转动画标签--&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="360" android:pivotX="50%" android:pivotY="50%" android:duration="4000"/&gt; &lt;!--透明度动画标签--&gt; &lt;alpha android:fromAlpha="1.0" android:toAlpha="0.2" android:duration="4000"/&gt;&lt;/set&gt; 从上面的代码我们知道，View动画既可以是单个动画，也可以有一系列动画组成。这是因为View动画的四种种类分别对应着Animation的四个子类（TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation），除了以上四个子类它还有一个AnimationSet类，对应xml标签为&lt;set&gt;，它是一个容器，可以包含若干个动画，并且内部也可以继续嵌套&lt;set&gt;集合的。我们在activity对TextView设置动画： 12345678910111213141516171819202122232425/** * @author power * @date 2018-08-08 20:28:58 * @description: MainActivity */public class MainActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textview); textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Animation animation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.viewanimation); textView.startAnimation(animation); &#125; &#125;); &#125;&#125; 我们来看下动画集合的运行效果： 1.2 View动画的属性详解 Animation属性详解： xml属性 java方法 解释 android:duration setDuration(long) 动画持续时间，毫秒为单位 android:ShareInterpolator setInterpolator(Interpolator) 设定插值器（指定的动画效果，譬如回弹等） android:fillAfter setFillAfter(boolean) 控件动画结束时是否保持动画最后的状态 android:fillBefore setFillBefore(boolean) 控件动画结束时是否还原到开始动画前的状态 android:repeatMode setRepeatMode(int) 重复类型有两个值，reverse表示倒序回放，restart表示从头播放 android:startOffset setStartOffset(long) 调用start函数之后等待开始运行的时间，单位为毫秒 TranslateAnimation属性详解： xml属性 java方法 解释 android:fromXDelta TranslateAnimation(float fromXDelta, …) 起始点X轴坐标，数值，百分比，百分比p，注① android:fromYDelta TranslateAnimation(…, float fromYDelta, …) 起始点Y轴从标，同上规律 android:toXDelta TranslateAnimation(…, float toXDelta, …) 结束点X轴坐标，同上规律 android:toYDelta TranslateAnimation(…, float toYDelta) 结束点Y轴坐标，同上规律 注①： 数值、百分数、百分数p，譬如50表示以当前View左上角坐标加50px为初始点、50%表示以当前View的左上角加上当前View宽高的50%做为初始点、50%p表示以当前View的左上角加上父控件宽高的50%做为初始点 ScaleAnimation属性详解： xml属性 java方法 解释 android:fromXScale ScaleAnimation(float fromX, …) 初始X轴缩放比例，1.0表示无变化 android:toXScale ScaleAnimation(…, float toX, …) 结束X轴缩放比例 android:fromYScale ScaleAnimation(…, float fromY, …) 初始Y轴缩放比例 android:toYScale ScaleAnimation(…, float toY, …) 结束Y轴缩放比例 android:pivotX ScaleAnimation(…, float pivotX, …) 缩放起点X轴坐标，数值，百分比，百分比p，注① android:pivotY ScaleAnimation(…, float pivotY) 缩放起点Y轴坐标，同上规律 RotateAnimation属性详解： xml属性 Java方法 解释 android:fromDegrees RotateAnimation(float fromDegrees, …) 旋转开始角度，正代表顺时针度数，负代表逆时针度数 android:toDegrees RotateAnimation(…, float toDegrees, …) 旋转结束角度，正代表顺时针度数，负代表逆时针度数 android:pivotX RotateAnimation(…, float pivotX, …) 缩放起点X坐标，数值，百分比，百分比p，注① android:pivotY RotateAnimation(…, float pivotY) 缩放起点Y坐标，同上规律 AlphaAnimation属性详解： xml属性 java方法 解释 android:fromAlpha AlphaAnimation(float fromAlpha, …) 动画开始的透明度（0.0到1.0，0.0是全透明，1.0是不透明） android:toAlpha AlphaAnimation(…, float toAlpha) 动画结束的透明度，同上 AnimationSet属性详解： AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，所以特别注意，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。譬如我们在set标签下加入duration=“1000”，子控件的duration属性会失效。 1.3 View动画的使用方法及注意事项 上述的使用方法已经非常详细了，也并没有什么难以理解的地方，我们只需要创建相应的xml文件，然后在activity里startAnimation就可以完成动画了。当然了，Animation类和View操作Animation还有一些如下的实用方法： Animation类的方法 解释 reset() 重置Animation的初始化 cancel() 取消Animation动画 start() 开始Animation动画 setAnimationListener() 给当前Animation设置动画监听 hasStarted() 判断当前Animation是否开始 hasEnded() 判断当前Animation是否结束 —————————- —————————- View类对Animation的操作方法 解释 startAnimation(Animation animation) 对当前View开始设置的Animation动画 clearAnimation() 取消当View在执行的Animation动画 注意事项 特别特别注意：补间动画执行之后并未改变View的真实布局属性值。切记这一点，譬如我们在Activity中有一个 Button在屏幕上方，我们设置了平移动画移动到屏幕下方然后保持动画最后执行状态呆在屏幕下方，这时如果点击屏幕下方动画执行之后的Button是没 有任何反应的，而点击原来屏幕上方没有Button的地方却响应的是点击Button的事件。 在进行动画的时候，尽量使用dp，因为px会导致适配问题。 1.4 View动画Interpolator插值器详解 插值器简介 首先，我们先看一下源码的解释： 注释说明：插值器定义了动画的变化，使一些基础的动画如（平移，缩放，旋转，透明）可以被加速，减速，重复等通过上图可以看见其实系统提供给我们的各类型插值器都是实现了Interpolator接口，具体如下： java类 xml 描述 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 动画始末速率较慢，中间加速 AccelerateInterpolator @android:anim/accelerate_interpolator 动画开始速率较慢，之后慢慢加速 AnticipateInterpolator @android:anim/anticipate_interpolator 开始的时候从后向前甩 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 类似上面AnticipateInterpolator BounceInterpolator @android:anim/bounce_interpolator 动画结束时弹起 CycleInterpolator @android:anim/cycle_interpolator 循环播放速率改变为正弦曲线 DecelerateInterpolator @android:anim/decelerate_interpolator 动画开始快然后慢 LinearInterpolator @android:anim/linear_interpolator 动画匀速改变 OvershootInterpolator @android:anim/overshoot_interpolator 向前弹出一定值之后回到原来位置 插值器的使用 插值器的使用比较简答，如下： 12345678910111213&lt;setxmlns:android="http://schemas.android.com/apk/res/android"&lt;!--运动结束时弹起--&gt;android:interpolator="@android:anim/bounce_interpolator"&gt;&lt;!--平移动画标签--&gt;&lt;translate android:fromXDelta="0%p" android:toXDelta="20%p" android:fromYDelta="0%p" android:toYDelta="20%p" android:duration="4000"/&gt;&lt;!--缩放动画标签--&gt;&lt;/set&gt; 我们看一下设置插值器后的效果： 插值器的自定义 当系统提供给我们的插值器不能满足开发需求时，就需要我们自定义，而插值器的自定义有两种方式，一种xml实现，一种java实现。 xml实现方式在anim文件下创建xml文件 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;accelerateInterpolatorxmlns:android="http://schemas.android.com/apk/res/android"android:factor="0.8"&gt;&lt;/accelerateInterpolator&gt; 通过代码我们发现，这种方式只能修改现有插值器的一些属性，但有些插值器不具备修改属性，那么我们就通过java代码实现进一步需求 java代码实现方式通过上面的学习我们知道，所有的插值器都是继承自Interpolator接口，它则继承TimeInterpolator接口，而这个接口定义了float getInterpolation(float input);方法 1234567public class AccelerateDecelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125;&#125; 12345678910111213141516public interface TimeInterpolator &#123;/** * Maps a value representing the elapsed fraction of an animation to a value that represents * the interpolated fraction. This interpolated value is then multiplied by the change in * value of an animation to derive the animated value at the current elapsed animation time. * * @param input A value between 0 and 1.0 indicating our current point * in the animation where 0 represents the start and 1.0 represents * the end * @return The interpolation value. This value can be more than 1.0 for * interpolators which overshoot their targets, or less than 0 for * interpolators that undershoot their targets. */float getInterpolation(float input);&#125; 我们需要继承Interpolator接口并实现getInterpolation();，在方法里处理业务逻辑即可。 2.Drawable Animation（帧动画）2.1帧动画概述帧动画是顺序播放一组预先定义好的图片，不同于View动画，系统提供了另外一个类AnimationDrawable来使用帧动画。 2.2帧动画的使用首先我们找一组帧动画的图片放入drawable-xhdpi文件夹下，其次在drawable文件夹下创建xml文件，如下所示： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/refresh1" android:duration="180"/&gt; &lt;item android:drawable="@drawable/refresh2" android:duration="180"/&gt; ... &lt;item android:drawable="@drawable/refresh25" android:duration="180"/&gt;&lt;/animation-list&gt; 123456789view = findViewById(R.id.view); view.setBackgroundResource(R.drawable.drawable_anim); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AnimationDrawable animationDrawable = (AnimationDrawable) view.getBackground(); animationDrawable.start(); &#125; &#125;); 通过上述代码，帧动画已经完成了，我们来看下效果图： &lt;animation-list&gt; 必须是根节点，包含一个或者多个&lt;item&gt;元素，属性有：android:oneshot true代表只执行一次，false循环执行。&lt;item&gt; 类似一帧的动画资源。 &lt;item&gt; animation-list的子项，包含属性如下：android:drawable 一个frame的Drawable资源。android:duration 一个frame显示多长时间。 帧动画很简单，但容易引起OOM，我在这里也就不多赘述。 3.Property Animation（属性动画）3.1 未完待续…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画(Animation)</tag>
      </tags>
  </entry>
</search>
