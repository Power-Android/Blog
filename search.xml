<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android架构组件（三）：Viewmodel]]></title>
    <url>%2F2019%2F10%2F24%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AViewModel%2F</url>
    <content type="text"><![CDATA[前言上篇我们分析了Livedata的使用及原理，相信我们已经学会了使用Livedata来存储数据，并在观察者组件中实现回调方法，来动态更新UI数据。这里奉上（双膝已经跪烂了…）上两篇的地址：Android架构组件（一）：LifecycleAndroid架构组件（二）：LiveData方便大家进行查阅和回顾。 那么，接下来我们要学习我们的第三个架构组件——Viewmodel，我们从字面上理解，它肯定和view，model有关联，它是负责准备和管理UI组件（activity/fragment）相关的数据类，也就是说Viewmodel是用来管理UI相关数据的，同时Viewmodel还可以负责UI间组件的通讯。 Viewmodel是什么？我们已经知道，Viewmodel有以下两点作用： 用来管理数据（model）和UI组件（view）的数据类 负责UI组件之间的通讯 管理数据（model）和UI组件（view）的数据我们先来看一下它的基本使用：1234567891011121314151617181920212223242526public class MyViewModel extends ViewModel &#123; //如果不熟悉Livedata用法可以阅读上一篇博客 private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // 异步调用获取用户列表 ... users.setValue(data); &#125;&#125;public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // 更新 UI &#125;); &#125;&#125; 用法很简单,我们在viewmodel中定义一个livedata的集合，通过网络获取数据后，调用setValue方法通知观察者(UI)在活跃状态下时更新数据。在activity中，我们初始化viewmodel拿到livedata并在他的onchanged()方法里做UI相关操作。这里我们发现viewmodel做了一个中间人的角色，它管理着model与view之间相互关联的数据，这样我们就可以把数据相关（model）操作放到viewmodel中，把UI操作放到view中，完全由viewmodel管理，使model与view层完全解耦。 负责UI间组件之间的通讯一个activity中的多个Fragment互相间通讯时很常见的需求，我们可以使用activity中的viewmodel来实现fragment之间数据的共享。下面这个例子也很简单：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//我们定义viewmodel并设置set，get方法public class CommunicateViewModel extends ViewModel &#123; private MutableLiveData&lt;String&gt; mNameLiveData; public LiveData&lt;String&gt; getName()&#123; if (mNameLiveData == null) &#123; mNameLiveData = new MutableLiveData&lt;&gt;(); &#125; return mNameLiveData; &#125; public void setName(String name)&#123; if (mNameLiveData != null) &#123; mNameLiveData.setValue(name); &#125; &#125;&#125;//我们通过fragment1设置name的值public class FragmentOne extends Fragment &#123; private CommunicateViewModel mCommunicateViewModel; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCommunicateViewModel = ViewModelProviders.of(getActivity()).get(CommunicateViewModel.class); &#125; @OnClick(R.id.btn_set_name) void onViewClicked(View v)&#123; switch (v.getId())&#123; case R.id.btn_set_name: mCommunicateViewModel.setName("Jane"); break; &#125; &#125;&#125;//在fragment2中我们通过同一个viewmodel拿到livedata并更新UIpublic class FragmentTwo extends Fragment &#123; private CommunicateViewModel mCommunicateViewModel; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCommunicateViewModel = ViewModelProviders.of(getActivity()).get(CommunicateViewModel.class); mCommunicateViewModel.getName().observe(this, name -&gt; mTvName.setText(name)); &#125;&#125; 上述代码我们知道了，两个fragment的是通过同一个viewmodel进行组件之间的通讯，这里值得注意的是两个fragment中初始化viewmodel时传入的都是getActivity() 这也就意味着他们传入的是同一个对象，如果不同，那么得到的将是两个viewmodel对象，也不会收到通知进行更新了。 这种组件间通讯的好处在于 activity不需要做任何事情 fragment不需要知道彼此，而是通过viewmodel进行联系 Viewmodel分析我们先来看下它的声明周期图：从上图我们分析得出，左侧表示Activity的生命周期状态，右侧绿色部分表示ViewModel的生命周期范围。当屏幕旋转的时候，Activity会被recreate，Activity会经过几个生命周期方法，但是这个时候ViewModel还是之前的对象，并没有被重新创建，只有当Activity的finish()方法被调用时，ViewModel.onCleared()方法会被调用，对象才会被销毁。这张图很好的描述了当Activity被recreate时，ViewModel的生命周期。 另外，有个注意的地方：在ViewModel中不要持有Activity的引用。为什么要注意这一点呢？从上面的图我们看到，当Activity被recreate时，ViewModel对象并没有被销毁，如果Model持有Activity的引用时就可能会导致内存泄漏。那如果你要使用到Context对象怎么办呢，ViewModel的子类AndroidViewModel为我们很好的解决了这一问题，我们稍后会分析。 我们再来看一下viewmodel的类图：根据这张类图，我们来分析一下： ViewModelProviders是ViewModel工具类，该类提供了通过Fragment和Activity得到ViewModel的方法，而具体实现又是由ViewModelProvider实现的。 123456789101112@NonNull@MainThreadpublic static ViewModelProvider of(@NonNull FragmentActivity activity,@Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; //param1是ViewModelStore，param2是工厂类 return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125;//他在of()方法里初始化了ViewModelProvider里的工厂类AndroidViewModelFactory，并renturn了ViewModelProvider对象//内部还有一些check方法用于检查Fragment是否Attached to Activity，Activity的Application对象是否为空等 ViewModelStores是ViewModelStore的工厂方法类，它会关联Fragment，activity上个代码片段我们看见它在of()方法里renturn时new了一个provider对象并通过ViewModelStores.of()得到stroe对象 123456789101112131415161718192021222324252627282930//ViewModelStores.of(activity)方法返回了ViewModelStore对象return new ViewModelProvider(ViewModelStores.of(activity), factory);public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; //我们看见这里有一个holderFragmentFor对象（HolderFragment） return holderFragmentFor(activity).getViewModelStore();&#125;public HolderFragment() &#123; //将这个方法设置为true就可以使当前Fragment在Activity重建时存活下来,如果不设置或者设置为false,当前Fragment会在Activity重建时同样发生重建,以至于被新建的对象所替代。 setRetainInstance(true); //这样就解决了旋转屏幕时因为重建导致数据丢失的问题&#125;//在HoldFragment中初始化了ViewModelStore用于在销毁时clear，释放掉viewmodelprivate ViewModelStore mViewModelStore = new ViewModelStore();@Override public void onDestroy() &#123; super.onDestroy(); mViewModelStore.clear(); &#125; @NonNull @Override public ViewModelStore getViewModelStore() &#123; return mViewModelStore; &#125; ViewModelStore是存储ViewModel的类，具体实现是通过HashMap来保存ViewModle对象。 123456789101112131415161718192021222324//viewmodelStroe用户存储Viewmodel，并提供set，get方法和clear方法public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; //这里调用了viewmodel的onCleared()方法 vm.onCleared(); &#125; mMap.clear(); &#125;&#125; ViewModelProvider是实现ViewModel创建、获取的工具类。在ViewModelProvider中定义了一个创建ViewModel的接口类——Factory。ViewModelProvider中有个ViewModelStore对象，用于存储ViewModel对象。 1234567891011121314151617181920212223//构造方法中我们传入了stroe和工厂类public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; this.mViewModelStore = store;&#125;//我们使用的.get(modele.class)方法最终会调用这个get方法public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; //从map中获取model对象 ViewModel viewModel = mViewModelStore.get(key); //判断是否是同一个对象？如果是return此viewmode if (modelClass.isInstance(viewModel)) &#123; return (T) viewModel; &#125; else &#123; if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; //如果不是则通过工厂类创建，然后缓存进stroe，并return viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;&#125; 好了，至此我们通过阅读源码，已经对viewmodel的工作原理有了一定的了解，那么们就来总结一下它如何通过一系列操作，来做到对view和model进行管理的。123456789101112131415161718192021222324252627282930313233343536373839404142//1. 首先我们会在继承viewmodel的类中，做一些数据操作（初始化livedata），并提供set,get方法返回livedata对象。（代码省略...查看开头基本用法的代码块）//2. 我们在view组件（activity/fragment）中拿到viewmodel对象MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);//3. of()方法返回viewmodelprodiver对象 public static ViewModelProvider of(@NonNull FragmentActivity activity,@Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; //4. 在of方法里初始化ViewModelProvider中AndroidViewModelFactory对象 factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; //5. ViewModelProvider中传入ViewModelstore和factory对象 return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125;//6. 工厂类 ViewModelStores.of(activity)方法返回ViewModelStore对象public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; //7.holderFragmentFor对象（HolderFragment）解决了屏幕旋转时数据保存。setRetainInstance(true);在里面初始化了ViewModelStore对象 return holderFragmentFor(activity).getViewModelStore();&#125;//8. 这时我们拿到了ViewModelProviders.of(this)返回的provider对象，然后调用get方法.get(MyViewModel.class);最终走到此get()方法public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; //从map中获取model对象 ViewModel viewModel = mViewModelStore.get(key); //判断是否是同一个对象？如果是return此viewmode if (modelClass.isInstance(viewModel)) &#123; return (T) viewModel; &#125; else &#123; if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; //如果不是则通过工厂类创建，然后缓存进stroe，并return viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;&#125;//9. 返回了viewmodel对象，通过viewmodel的get方法拿到livedata对象，并在ui组件处于活跃状态时更新UImodel.getUsers().observe(this, users -&gt; &#123; // 更新 UI &#125;); 参考&amp;感谢Android架构组件——ViewModel 玩Android 总结Viewmodel的职责是为UI组件管理数据。规范化viewmodel的使用方式，不要在viewmodel层中持有UI层的引用，避免因viewmodel超长的生命周期，导致内存泄漏。实现UI组件和数据间的管理和解耦，才是这个框架带给我们的理解。通过我们对源码的分析，它的功能并不复杂，但设计的十分巧妙，背后掺杂的思想和理念才是值得去反复揣度的。它可以更好的实现把业务代码下沉到viewmodel中实现，既保证了UI组件中代码的清爽，又可以实现对数据的管理。 Viewmodel可以用于activity中不同fragment之间的通信，也可以用作Fragment之间一种解耦方式。 接下来我们会讲到Android架构的另一个组件Room，来看下这个数据库能带给我们哪些惊艳？当学习完所有的组件后，我们就开始尝试着去搭一款适合自己的MVVM框架，用于加深我们对Android架构组件的学习，从而做到学以致用。 Android架构组件系列文章我的博客（Power）Android架构组件（一）：LifecycleAndroid架构组件（二）：LiveDataAndroid架构组件（三）：Viewmodel 感谢您的阅读和支持！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android架构组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android架构组件（二）：LiveData]]></title>
    <url>%2F2019%2F10%2F22%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALiveData%2F</url>
    <content type="text"><![CDATA[前言上篇文章我们分析了Lifecycle的使用和原理，相信我们已经学会了用Lifecycle将你所需的类添加声明周期管理，如果只是寥寥阅读也没关系，这里奉上（双膝跪地）上篇地址，Android架构组件（一）：Lifecycle，方便大家进行回顾。 那么接下来我们就要学习第二个架构组件——LiveData，它是一个可观察的数据处理类，通过观察者模式，感知与其共生的其它组件的生命周期（例如：Activity，Fragment等），进而确保Livedata仅更新处于活跃状态下组件的观察者。 接下来我将和大家一起了解和使用这些组件。系列文章也会收录到我的博客（Power）里，方便大家查阅。 LiveData是什么？我们已经知道Livedata是一个可观察的数据处理类，它拥有以下几个特点： 数据可以被观察者订阅 能够感知组件（activity，fragment，service）的生命周期 只有观察者处于（STRATED、RESUMED）状态，Livedata才会认为其处于活跃状态下面我们来看下它的用法：1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private MutableLiveData&lt;String&gt; mLiveData; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLiveData = new MutableLiveData&lt;&gt;(); mLiveData.observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String s) &#123; Toast.makeText(MainActivity.this, "数据已更新：" + s, Toast.LENGTH_SHORT); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); mLiveData.setValue("欢迎学习Livedata！"); &#125;&#125; 如你所见，Livedata其实就是一个存储数据的容器，每当容器里的数据发生变化，我们就可以从回调函数进行数据的操作。这很像我们控件的点击监听方法setOnclickListener();，其实点击事件的监听方法也是观察者模式，对于观察者来说，他并不关心数据是怎么来的，而是关心数据过来后如何处理。 LiveData优势有哪些？ 确保数据和UI保持统一。 Livedata遵循观察者模式，其相当于被观察者。当生命周期或数据发生变化时，Livedata会通知Observer对象，并更新UI。 不会发生内存泄漏。 这要得益于我们上篇讲的架构组件——Lifecycle，观察者Livedata会绑定Lifecycle，并在其关联的组件生周期遭到销毁后进行自我处理。 我们来观察下它的源码：12345678910@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; //LifecycleBoundObserver对象本质实现了lifecycle的LifecycleObserver接口，监听被观察者的状态改变 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); //下行代码的mObservers是Livedata为了管理每一个观察者对象创建的Map集合，并把每个观察者对象存进了集合 ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); ... //绑定生命周期 owner.getLifecycle().addObserver(wrapper); &#125; 首先，我们看到注解@MainThread知道，这个方法必须运行在主线程中。两个参数中第一个参数其实是Activity/Fragment被抽象成了LifecycleOwner，学过上篇文章的可以很好理解，第二个参数Observer其实就是观察后的回调。其次，我们看内部的实现方法。LifecycleBoundObserver对象就是传入了这两个参数，它被包装成了另一个对象，在它的内部实现了Lifecycle组件中的LifecycleObserver接口，和activity的生命周期进行绑定，在发生改变时及时更新Livedata的状态变化。1234567891011121314151617181920class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; //每当activity的生命周期发生变化时都会回调该方法 @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; //更新Livedata的活跃状态 shouldBeactive方法里会判断状态是否是START并返回boolean值 activeStateChanged(shouldBeActive()); &#125; ...&#125; 这就解释了为什么Livedata为什么不会发生内存泄漏问题，因为它和activity/fragment绑定了生命周期，在页面销毁时及时释放了内存。 数据始终保持最新状态。 如果activity的状态再次从非活跃状态转换到活跃状态时会接收最新的数据。例如，曾经在后台的activity再返回前台后立刻更新数据。 适当的配置修改。 例如旋转设备时activity重建后会立即更新数据。 数据更新后如何通知到回调方法？Livedata 提供了两种方式供开发者更新数据，分别是 setvalue() 和 postValue() ；官方文档明确说明：setValue() 方法必须在主线程调用，而 postValue() 更适合在子线程中进行调用（比如网络请求等）。我们先来看下setValue() 方法的实现原理： 1234567891011121314151617181920212223242526272829303132333435363738394041@MainThreadprotected void setValue(T value) &#123; //如果在子线程中调用会抛出异常 assertMainThread("setValue"); //更新内容器中的数据，自增version，赋值data mVersion++; mData = value; //循环调度容器中的值 dispatchingValue(null);&#125;private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; //逐一让容器里的所有观察者执行这个通知方法 considerNotify(iterator.next().getValue()); ...&#125;//上文的代码块我们知道这个considerNotify方法的参数就是LifecycleBoundObserver对象，内部实现了状态的监听。（记忆不深刻的可以翻上去看一眼）private void considerNotify(ObserverWrapper observer) &#123; //如果观察者不处于活跃状态，直接return if (!observer.mActive) &#123; return; &#125; //再次检查状态，防止状态改变了但未收到通知 if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; //如果version小于之前的version，直接return if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; /* * 处于活跃状态时调用livedata.observe()的第二个参数Observer里的onchanged方法， * 把新赋值的data传过去，实现回调 */ observer.mObserver.onChanged((T) mData); &#125; 通过setValue()的核心方法我们知道它是如何通知并进行回调的了。但通常情况下Android是不允许在子线程中更新UI的，但是postValue() 方法却可以在子线程中更新livedata的数据，并通知UI进行更新，这是如何实现的呢？我们来看一下postValue() 的源码：123456789101112131415161718192021222324protected void postValue(T value) &#123; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;public void postToMainThread(Runnable runnable) &#123; //获取主线程的looper，通过handle发送事件 if (mMainHandler == null) &#123; synchronized (mLock) &#123; if (mMainHandler == null) &#123; mMainHandler = new Handler(Looper.getMainLooper()); &#125; &#125; &#125; //发送事件后在Livedata中回调run方法 mMainHandler.post(runnable);&#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; //其实post方法最终还是调用的set方法 setValue((T) newValue); &#125;&#125;; 我们分析到这里，想必我们对Livedata的工作原理有了一些了解，那么我们继续来探索它更细节的地方和用法吧。 更多探索 我们知道Livedata只有观察者处于STARTED和RESUMED状态时，才会被认为是活跃状态，并更新相应数据和UI，这里我贴出大神&lt;却把青梅嗅&gt;的图片从上述代码我们知道，livedata只收到了onStart，onResume，onPause这三个生命周期的回调，这是因为我们上述代码中有一个经常遇见的方法shouldBeActive() ，他的内部会进行比较compareTo，只有大于等于START状态才返回true，源码里我们发现只有STARTED和RESUME，否则直接return掉。当然我们有时候碰见的需求要求activity在后台时依然能够响应数据的变更，那怎么办呢？不要慌，Livedata还提供了observerForever() 方法，在这种情况下，它能够响应到任何生命周期中数据的变更事件：observerForever()方法的源码也很巧妙，他的AlwaysActiveObserver继承自ObserverWrapper并重写了shoudlbeActive方法，并直接返回true，有兴趣的可以去源码里体验一下livedata的巧妙之处。 将Livedata与Room一起使用。其实Room数据存储库支持返回Livedata对象的可观察查询，毕竟是一个老父亲嘛，想象这几个架构组件相互之间的关联与合作可以更加高效的为我们提供更稳定，安全的环境。当数据库更新时，Room 会生成更新 LiveData 对象所需的所有代码。在需要时，生成的代码会在后台线程上异步运行查询。此模式有助于使界面中显示的数据与存储在数据库中的数据保持同步。后续的文章中我们会详细介绍这两个组件之间的协作。 Livedata还有更多的用法扩展，我将会在后续的学习中不断的补充，把更好更优秀的方案和数据处理方式分享给大家。 参考&amp;感谢Android官方架构组件LiveData 玩Android 总结我们通过文章已经基本了解了Livedata的工作原理，通过观察者模式和生命周期的绑定，我们可以更高效便捷的对数据进行处理并在适当的时候更新UI。当然，Livedata还有许多的用法我还没有接触到，也希望和各位同学一起学习进步。接下来我们会讲到Android架构的另一个组件Viewmodel，我相信学习完viewmodel以后，我们可以尝试把这三个组件串联起来，体会它们所带给我们极佳的代码体验。当学习完所有的组件后，我们就开始尝试着去搭一款适合自己的MVVM框架，用于加深我们对Android架构组件的学习，从而做到学以致用。 Android架构组件系列文章我的博客（Power）Android架构组件（一）：LifecycleAndroid架构组件（二）：LiveData 感谢您的阅读和支持！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android架构组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android架构组件（一）：Lifecycle]]></title>
    <url>%2F2019%2F10%2F18%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ALifecycle%2F</url>
    <content type="text"><![CDATA[前言谷歌在17年发布了Android架构组件1.0稳定版，用来帮助开发者们简化开发流程，并为App的开发架构提供指南。这次发布的架构包含了声明周期管理，数据持久性等提供了一系列库，并且该架构相互之间完美的融合到了一起，有助于我们使用更少的样板代码写出模块化的App。他们包含： Lifecycle（生命周期管理） LiviData（基于观察者模式的可感知生命周期的数据持有类） Viewmodel（将view和model分开的组件） Room（简单强大的数据存储组件） 接下来我会用一系列文章和大家一起了解和使用这些组件。系列文章也会收录到我的博客（Power）里，方便大家查阅。 好了，首先我们先来学习下基础组件：Lifecycle 什么是Lifecycle？在讲解之前，我们先来分析下没用该组件之前我们常用的MVP模式中，Presenter是如何绑定activity/Fragment的生命周期？123456789101112131415161718192021222324//presenterPublic class Presenter&#123; public void attachView(T view) &#123; //do something &#125; public void detachView() &#123; //do something &#125;&#125;//activitypublic class Activity extends AppCompatActivity&#123; private Presenter presenter; public void onCreate(...) &#123; presenter= new Presenter(); presenter.attachView(this); &#125; public void onDestroy() &#123; super.onDestroy(); presenter.detachView(); &#125;&#125; 相信大多数开发者对上述代码很清楚了，我们常把activity和prsenter的绑定和分离都写在了base基类里用于同步两者的生命周期。上述的代码并没有什么逻辑错误，不过接下来的Lifecycle会让生命周期管理变得更加丝滑~123456789101112131415161718192021222324252627282930313233343536/* * presenter继承LifecycleObserver * 1.通过注解的方式实现Lifecycle的观察者方法 */Public class Presenter extends LifecycleObserver&#123; @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onAny(LifecycleOwner owner, Lifecycle.Event event) &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate() &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy() &#123; &#125;&#125;/* * 在activity里添加Observer */ public class Activity extends AppCompatActivity&#123; private Presenter presenter; public void onCreate(...) &#123; presenter= new Presenter(); //2.添加LifecycleObserver实现同步 getLifecycle().addObserver(presenter); &#125; public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 通过上述代码我们了解到，presenter通过继承LifecycleObserver实现生命周期方法，并在activity/Fragment中addObserver()中传入presenter对象就可以绑定两者的生命周期了。而且Lifecycle提供了所有的生命周期事件，选择你所需要的生命周期并通过注解进行声明就可以了。12345678910111213141516171819202122232425262728293031323334@OnLifecycleEvent(Lifecycle.Event.ON_ANY)void onAny(LifecycleOwner owner, Lifecycle.Event event) &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)void onCreate() &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)void onDestroy() &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_START)void onStart() &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_STOP)void onStop() &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)void onResume() &#123;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)void onPause() &#123;&#125; 那么，Lifecycle的工作原理是什么？我们继续分析。 Lifecycle的工作原理我们先祭出一张整体架构图： 我们来看下大致的工作原理： Lifecycle（生命周期）：该抽象类提供了addOberserver，removeObser，getCurrentState抽象方法，生命周期的事件和状态的枚举类。 1234567891011121314151617181920212223242526272829303132333435public abstract class Lifecycle &#123; @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); @MainThread @NonNull public abstract State getCurrentState(); @SuppressWarnings("WeakerAccess") public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY &#125; @SuppressWarnings("WeakerAccess") public enum State &#123; DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125;&#125; LifecycleObserver接口（Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。 LifecycleOwner接口（Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。该接口提供了getLifecycle()方法返回Lifecycle对象 12345@SuppressWarnings(&#123;"WeakerAccess", "unused"&#125;)public interface LifecycleOwner &#123; @NonNull Lifecycle getLifecycle();&#125; activity继承的AppCompatActivity父类v4包里的FragmentActivity已经实现了该接口，v4包里的fragment同理也替我们实现了LifecycleObserver接口。1234567891011121314151617//AppCompatActivity继承自FragmentActivity继承自SupportActivity，该类里的getLifecycle()方法返回了lifecycle对象public class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, OnRequestPermissionsResultCallback, RequestPermissionsRequestCodeValidator &#123; ... public Lifecycle getLifecycle() &#123; return super.getLifecycle(); &#125;&#125;public class SupportActivity extends Activity implements LifecycleOwner, Component &#123; ... private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); public Lifecycle getLifecycle() &#123; return this.mLifecycleRegistry; &#125;&#125;//fragment同理，就不贴代码了，大家可以去源码里查看。 从上述的代码我们不难发现，实现的getLifecycle()方法，实际上返回的是 LifecycleRegistry对象，LifecycleRegistry对象实际上继承了Lifecycle123public class LifecycleRegistry extends Lifecycle &#123; ...&#125; 那么持有Lifecycle对象有什么作用呢？实际上Fragment已经给出了答案。在fragment的生命周期方法中LifecycleRegistry都会发送对应的生命周期事件给内部的handleLifecycleEvent()方法；12345678910111213141516171819202122232425262728293031323334353637383940public class Fragment implements xxx, LifecycleOwner &#123; //... void performCreate(Bundle savedInstanceState) &#123; onCreate(savedInstanceState); //1.先执行生命周期方法 //... //2.生命周期事件分发 mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); &#125; void performStart() &#123; onStart(); //... mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); &#125; void performResume() &#123; onResume(); //... mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); &#125; void performPause() &#123; //3.注意，调用顺序变了 mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); //... onPause(); &#125; void performStop() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); //... onStop(); &#125; void performDestroy() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); //... onDestroy(); &#125;&#125; fragment把事件发送出去后，都做了什么事情？接下来我们来看下LifecycleRegistry内部的实现12345678910111213141516171819202122232425262728293031public class LifecycleRegistry extends Lifecycle &#123; ... public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next); &#125; private void moveToState(State next) &#123; ... sync(); &#125; private void sync() &#123; ... //通过里边的backwardPass()和forwardPass()方法循环遍历 &#125; private void forwardPass(LifecycleOwner lifecycleOwner) &#123; ... while (...) &#123; ... ObserverWithState observer = entry.getValue(); while (...) &#123; //通知状态变化 pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125; &#125;&#125; 通过代码我们了解到handleLifecycleEvent里通过getStateAfter()方法获取当前的状态，并且通过moveToState() 方法修改Lifecycle的状态值，紧接着遍历所有LifecycleObserver 并同步且通知其状态发生变化，因此就能触发已经实现LifecycleObserver接口的类中对应的生命周期事件。 现在是时候祭出 Lifecycle时序图 来更好的理解工作原理 以上就是Lifecycle的基本工作原理，为缩短文章篇幅和可读性，文章里涉及的代码是源码的精简版，如若原理不详细，请移步源码阅读。 参考&amp;感谢Android官方架构组件Lifecycle:生命周期组件详解&amp;原理分析 玩Android 总结我们通过文章已经基本了解了lifecycle的工作原理，并且利用lifecycle可以更好对一些事件进行生命周期的管理。其实lifecycle原生支持livedata（顾名思义，动态数据容器），所以我们下一篇的重点就是学习和分析livedata的用法和构造。这几年在开发过程中一直使用MVP架构，并且项目结构变大以后非常多的接口类出现了，导致项目中很臃肿。也在不少博客中看到MMVM的架构的应用，但是对于许多架构了解不深刻，导致代码阅读很吃力，才有了系统学习Android架构的想法，并且计划学习完Android架构系列以后，试着搭建自己的MVVM框架，并逐渐延伸到组件化开发，从而做到真正的学以致用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android架构组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习（二）：控制语句详解篇]]></title>
    <url>%2F2019%2F08%2F14%2FKotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E8%AF%A6%E8%A7%A3%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言通过上一篇的学习，我们对kotlin已经掌握了函数的定义，基本数据类型，null安全设计，类型检测及自动转换和Kotlin的区间表达式，如果您还有任何不明白的地方，请跳转至我的上一篇博客：《Kotlin学习（一）：我TM谢谢你！(基础语法篇)》对于kotlin，这只是最基础的入门讲解，也希望大家能够跟我一样逐渐适应kotlin的美，我们一起进步，我相信通过一段时间的学习，我也可以像大家分享一些kotlin的语法糖以及更深入的使用。我的博客（Power） kotlin控制语句详解 条件控制语句：if 语句、when 语句 循环控制语句：for 循环、while与do…while 循环 返回和跳转语句：return、 break、 continue 1. if语句kotlin的if表达式其实和java是非常类似的，唯一不同的地方在于kotlin可以把表达式的结果赋值给变量，类似于java的三元运算符，我们可以直接实现。1234567891011121314// 传统用法var max = a if (a &lt; b) max = b// 使用 else var max: Intif (a &gt; b) &#123; max = a&#125; else &#123; max = b&#125; // 作为表达式val max = if (a &gt; b) a else b 举例：123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; var x = 0 if(x&gt;0)&#123; println("x 大于 0") &#125;else if(x==0)&#123; println("x 等于 0") &#125;else&#123; println("x 小于 0") &#125; var a = 1 var b = 2 val c = if (a&gt;=b) a else b println("c 的值为 $c")&#125;//输出结果为：x 等于 0c 的值为 2 2. when表达式when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。我们看下例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344//在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // 注意这个块,else 相当于 switch 的 default print("x 不是 1 ，也不是 2") &#125;&#125;//如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔when (x) &#123; 0, 1 -&gt; print("x == 0 or x == 1") else -&gt; print("otherwise")&#125;//我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125;//另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125;//when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125;//when 中使用 in 运算符来判断集合内是否包含某实例fun main(args: Array&lt;String&gt;) &#123; val items = setOf("apple", "banana", "kiwi") when &#123; "orange" in items -&gt; println("juicy") "apple" in items -&gt; println("apple is fine too") &#125;&#125; 举例：123456789101112131415161718192021222324fun main(args: Array&lt;String&gt;) &#123; var x = 0 when (x) &#123; 0, 1 -&gt; println("x == 0 or x == 1") else -&gt; println("otherwise") &#125; when (x) &#123; 1 -&gt; println("x == 1") 2 -&gt; println("x == 2") else -&gt; &#123; // 注意这个块 println("x 不是 1 ，也不是 2") &#125; &#125; when (x) &#123; in 0..10 -&gt; println("x 在该区间范围内") else -&gt; println("x 不在该区间范围内") &#125;&#125;//输出结果：x == 0 or x == 1x 不是 1 ，也不是 2x 在该区间范围内 3. for循环 for 循环可以对任何提供迭代器（iterator）的对象进行遍历 kotlin 废除了 java 的 for(int i = 0; i &lt; list.size(); i++)规则，新增了其他的规则，来满足对数组或集合的遍历 循环数组会编译成优化的实现而不会创建额外对象，或者你可以用库函数 withIndex：123456789101112131415//for循环可以对任何提供迭代器（iterator）的对象进行遍历for (item in collection) print(item)for (item: Int in ints) &#123; // ……&#125;//如果你想要通过索引遍历一个数组或者一个 listfor (i in array.indices) &#123; print(array[i])&#125;//循环数组会编译成优化的实现而不会创建额外对象，或者你可以用库函数 withIndex：for ((index, value) in array.withIndex()) &#123; println("the element at $index is $value")&#125; 举例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 循环5次，且步长为1的递增for (i in 0 until 5)&#123; print("i =&gt; $i \t")&#125;// 循环5次，且步长为1的递减for (i in 15 downTo 11)&#123; print("i =&gt; $i \t")&#125;print("使用 符号`..`的打印结果\n")for (i in 20 .. 25)&#123; print("i =&gt; $i \t")&#125;print("使用until的打印结果\n")for (i in 20 until 25)&#123; print("i =&gt; $i \t")&#125;//输出结果：使用 符号`..`的打印结果i =&gt; 20 i =&gt; 21 i =&gt; 22 i =&gt; 23 i =&gt; 24 i =&gt; 25 使用until的打印结果i =&gt; 20 i =&gt; 21 i =&gt; 22 i =&gt; 23 i =&gt; 24 //使用数组的indices属性遍历var arrayListTwo = arrayOf(1,3,5,7,9)for (i in arrayListTwo.indices)&#123; println("arrayListTwo[$i] =&gt; " + arrayListTwo[i])&#125;//输出结果：arrayListTwo[0] =&gt; 1arrayListTwo[1] =&gt; 3arrayListTwo[2] =&gt; 5arrayListTwo[3] =&gt; 7arrayListTwo[4] =&gt; 9//使用数组的withIndex()方法遍历var arrayListTwo = arrayOf(1,3,5,7,9)for ((index,value) in arrayListTwo.withIndex())&#123; println("index =&gt; $index \t value =&gt; $value")&#125;//输出结果：index =&gt; 0 value =&gt; 1index =&gt; 1 value =&gt; 3index =&gt; 2 value =&gt; 5index =&gt; 3 value =&gt; 7index =&gt; 4 value =&gt; 9 4. while， do…while语句kotlin的while语句和java的while语句一样，下面我们直接举栗：123456789101112131415161718192021222324252627282930313233343536373839404142var num = 5var count = 1while (num &lt; 10)&#123; println("num =&gt; $num") println("循环了$count 次") count++ num++&#125;//输出结果：num =&gt; 5循环了1 次num =&gt; 6循环了2 次num =&gt; 7循环了3 次num =&gt; 8循环了4 次num =&gt; 9循环了5 次//do...while语句var num = 5var count = 1do &#123; println("num =&gt; $num") println("循环了$count 次") count++ num++&#125;while (num &lt; 10)//输出结果：num =&gt; 5循环了1 次num =&gt; 6循环了2 次num =&gt; 7循环了3 次num =&gt; 8循环了4 次num =&gt; 9循环了5 次// *注* : do&#123;...&#125;while(exp)与while(exp)&#123;...&#125;最大的区别是do&#123;...&#125;while(exp)最少执行一次，这点也是和Java相同的 5. 返回和跳转语句return、break、continue的用法和java是一样的， eturn。默认从最直接包围它的函数或者匿名函数返回 break。终止最直接包围它的循环 continue。继续下一次最直接包围它的循环我们直接看代码吧： 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) &#123; if (i==3) continue // i 为 3 时跳过当前循环，继续下一次循环 println(i) if (i&gt;5) break // i 为 6 时 跳出循环 &#125;&#125;//输出结果为：1 2 4 5 6fun returnExample()&#123; var str: String = "" if (str.isBlank())&#123; println("我退出了该方法") return &#125;&#125;//输出结果为：我退出了该方法 Break 和 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习（一）：我TM谢谢你！(基础语法篇)]]></title>
    <url>%2F2019%2F07%2F30%2FKotlin%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%88%91TM%E8%B0%A2%E8%B0%A2%E4%BD%A0%EF%BC%81(%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[前言自从2017年Google定义Kotlin为Android开发的官方语言，瞬间掀起了学习大潮，各种学习博客如雨后春笋般攻击我这颗弱小而又无助的小心脏！是你们，是的，就是因为你们使我变得越来越强大，我TM替我日益稀疏的头发谢谢各位学霸！！！所以，搞起来吧！开启我们从乌黑亮丽到寸草不生的kotlin学习之旅！我的博客（Power） 作为Android开发水军中的一员，其实很早就简单看了语法，其中的优缺点这里就不再过多陈述，不清楚或想详细了解的请自行社会你度十三娘，鉴于大家如果能有幸看见这边文章，想必对我们吃饭的家伙熟悉程度应该不亚于我了，所以对于Android studio的环境配置这里小弟就不再卖弄风骚了，毕竟在座的各位都是学霸，VIP中P…这里在开头也为大家分享一些大牛关于学习Kotlin的链接，有助于大家在吃百家饭的时候，不容易养成挑食的小毛病。本系列均踩在各位巨人的肩膀上总结而成！请各位看官轻喷…Kotlin语言中国Kotlin-菜鸟教程Kotlin入门到进阶玩Android-kotlin文章 Kotlin基础语法 函数的定义 函数使用关键字 fun，参数格式为：参数 : 类型 1234// sum:函数名 a,b参数名，Int参数类型fun sum(a: Int, b: Int): Int &#123;// :后边Int为返回值类型 return a + b&#125; 这里需要注意如果是public则必须声明返回值类型，如果是无返回值的函数（:Unit）则可以省略。 12345678910fun unitFun() : Unit&#123; println("我是返回值为Unit的函数，Unit可省略") return // return Unit 可省略 // 或者 return 可省略&#125;//等价于fun unitFun()&#123; println("我是返回值为Unit的函数，Unit可省略")&#125; 可变长参数函数，用 vararg 关键字进行标识 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; 常量与变量 变量：var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 12var x: Int = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 常量：val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 1234val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值 Kotlin基本数据类型基础数据类型包含有： 数值类型 字符类型 字符串类型 布尔类型 数组类型 数值类型（Numbers） Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等 不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Byte 8 Short 16 Int 32 Long 64 Float 32 Double 64 字符类型（Characters） 和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’ 123456val ch :Char = 1; // 错误示范val ch :Char = '1'; // 正确示范// 将字符类型转换成数字val ch :Char = '8';val a :Int = ch.toInt() 字符串类型（Strings） 和 Java 一样，String 是不可变的。 12345678910111213141516171819202122//1.方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：for (c in str) &#123; println(c)&#125;//2.支持三个引号 """ 扩起来的字符串，支持多行字符串，比如：fun main(args: Array&lt;String&gt;) &#123; val text = """ 多行字符串 多行字符串 """ println(text) // 输出有一些前置空格&#125;//3.String 可以通过 trimMargin() 方法来删除多余的空白:fun main(args: Array&lt;String&gt;) &#123; val text = """ |多行字符串 |菜鸟教程 |多行字符串 |Runoob """.trimMargin() println(text) // 前置空格删除了&#125; 字符串模板：即在字符串内通过一些小段代码求值并把结果合并到字符串中。模板表达式以美元符（$）开头 1234567891011fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = "i = $i" println(s) // 求值结果为 "i = 10"&#125;//用花括号扩起来的任意表达式:fun main(args: Array&lt;String&gt;) &#123; val s = "runoob" val str = "$s.length is $&#123;s.length&#125;" println(str) // 求值结果为 "runoob.length is 6"&#125; 布尔类型（Boolean） 布尔用 Boolean 类型表示，它有两个值：true 和 false。 内置的布尔运算有： 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组类型（Arrays） 数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。 123456789fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant） 除了类Array，还有ByteArray, ShortArray, IntArray等等，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样： 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] Kotlin的Null安全设计 声明可为null参数及null判断处理 类型后面加 ？ 即表示可为null 进行判null处理时有两种方式： 第一种就是字段后加 !! 表示像java一样抛出null异常 第二种就是字段后加 ? 表示不作处理，可以返回null 第三种就是字段后加 ?: 表示字段为null时返回的值 当然， if/else也是可以的，在使用if判null后，可自动转换为非null变量 12345678//类型后面加?表示可为空var age: String? = "23" //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 函数中使用可null类型 当一个函数/方法有返回值时，如果方法中的代码使用?.去返回一个值，那么方法的返回值的类型后面也要加上 ? 符号 12345fun funNullMethod() : Int? &#123; val str : String? = "123456" return str?.length&#125;//输出：6 Kotlin的类型检测及自动类型转换 我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字) 12345678910111213141516171819202122232425262728fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125;//或者fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125;//甚至还可以fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; Kotlin的区间表达式 区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125;//实测示例fun main(args: Array&lt;String&gt;) &#123; print("循环输出：") for (i in 1..4) print(i) // 输出“1234” println("\n----------------") print("设置步长：") for (i in 1..4 step 2) print(i) // 输出“13” println("\n----------------") print("使用 downTo：") for (i in 4 downTo 1 step 2) print(i) // 输出“42” println("\n----------------") print("使用 until：") // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println("\n----------------")&#125; /* 输出结果： 循环输出：1234 ---------------- 设置步长：13 ---------------- 使用 downTo：42 ---------------- 使用 until：123 ---------------- */]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android三种动画详解]]></title>
    <url>%2F2019%2F01%2F08%2FAndroid%E4%B8%89%E7%A7%8D%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言自尊，自律，自强，自爱。–Power 一直以来自己对Android的动画一知半解，所以决定写这篇文章来详细系统的学习Android的三种动画，即 View Animation（视图动画） Drawable Animation（帧动画） Property Animation（属性动画） 正文1.View Animation（视图动画）1.1 View动画的概述及种类视图动画的作用对象是View，支持四种动画效果，分别是平移动画，缩放动画，旋转动画，透明度动画。譬如，我们可以对TextView设置其文本的移动，旋转，缩放，透明。 视图动画可以通过XML或通过代码动态创建，对于视图动画建议使用XML文件定义，因为它具有更高的可读性，可重用性。 下面我们来分别看一下View动画的四种效果： 平移动画（TranslateAnimation） 缩放动画（ScaleAnimation） 旋转动画（RotateAnimation） 透明度动画（AlphaAnimation） view动画的四种变换我们通过效果图已基本了解，下面我们通过表格系统的了解一下： 名称 标签 子类 效果 平移动画 &lt; translate &gt; TranslateAnimation 移动View 缩放动画 &lt; scale &gt; ScaleAnimation 方法或缩小View 旋转动画 &lt; rotate &gt; RotateAnimation 旋转view 透明度动画 &lt; alpha &gt; AlphaAnimation 改变View的透明度 要使用View动画，首先要创建XML文件，我们需要在res下新建anim文件夹，接着在anim下创建animation resource file的xml文件，我们举例为view_anim.xml 我们通过xml文件来了解它们各自的语法： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--平移动画标签--&gt; &lt;translate android:fromXDelta="0%p" android:toXDelta="20%p" android:fromYDelta="0%p" android:toYDelta="20%p" android:duration="4000"/&gt; &lt;!--缩放动画标签--&gt; &lt;scale android:fromXScale="1.0" android:toXScale="0.2" android:fromYScale="1.0" android:toYScale="0.2" android:pivotX="50%" android:pivotY="50%" android:duration="4000"/&gt; &lt;!--旋转动画标签--&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="360" android:pivotX="50%" android:pivotY="50%" android:duration="4000"/&gt; &lt;!--透明度动画标签--&gt; &lt;alpha android:fromAlpha="1.0" android:toAlpha="0.2" android:duration="4000"/&gt;&lt;/set&gt; 从上面的代码我们知道，View动画既可以是单个动画，也可以有一系列动画组成。这是因为View动画的四种种类分别对应着Animation的四个子类（TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation），除了以上四个子类它还有一个AnimationSet类，对应xml标签为&lt;set&gt;，它是一个容器，可以包含若干个动画，并且内部也可以继续嵌套&lt;set&gt;集合的。我们在activity对TextView设置动画： 12345678910111213141516171819202122232425/** * @author power * @date 2018-08-08 20:28:58 * @description: MainActivity */public class MainActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textview); textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Animation animation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.viewanimation); textView.startAnimation(animation); &#125; &#125;); &#125;&#125; 我们来看下动画集合的运行效果： 1.2 View动画的属性详解 Animation属性详解： xml属性 java方法 解释 android:duration setDuration(long) 动画持续时间，毫秒为单位 android:ShareInterpolator setInterpolator(Interpolator) 设定插值器（指定的动画效果，譬如回弹等） android:fillAfter setFillAfter(boolean) 控件动画结束时是否保持动画最后的状态 android:fillBefore setFillBefore(boolean) 控件动画结束时是否还原到开始动画前的状态 android:repeatMode setRepeatMode(int) 重复类型有两个值，reverse表示倒序回放，restart表示从头播放 android:startOffset setStartOffset(long) 调用start函数之后等待开始运行的时间，单位为毫秒 TranslateAnimation属性详解： xml属性 java方法 解释 android:fromXDelta TranslateAnimation(float fromXDelta, …) 起始点X轴坐标，数值，百分比，百分比p，注① android:fromYDelta TranslateAnimation(…, float fromYDelta, …) 起始点Y轴从标，同上规律 android:toXDelta TranslateAnimation(…, float toXDelta, …) 结束点X轴坐标，同上规律 android:toYDelta TranslateAnimation(…, float toYDelta) 结束点Y轴坐标，同上规律 注①： 数值、百分数、百分数p，譬如50表示以当前View左上角坐标加50px为初始点、50%表示以当前View的左上角加上当前View宽高的50%做为初始点、50%p表示以当前View的左上角加上父控件宽高的50%做为初始点 ScaleAnimation属性详解： xml属性 java方法 解释 android:fromXScale ScaleAnimation(float fromX, …) 初始X轴缩放比例，1.0表示无变化 android:toXScale ScaleAnimation(…, float toX, …) 结束X轴缩放比例 android:fromYScale ScaleAnimation(…, float fromY, …) 初始Y轴缩放比例 android:toYScale ScaleAnimation(…, float toY, …) 结束Y轴缩放比例 android:pivotX ScaleAnimation(…, float pivotX, …) 缩放起点X轴坐标，数值，百分比，百分比p，注① android:pivotY ScaleAnimation(…, float pivotY) 缩放起点Y轴坐标，同上规律 RotateAnimation属性详解： xml属性 Java方法 解释 android:fromDegrees RotateAnimation(float fromDegrees, …) 旋转开始角度，正代表顺时针度数，负代表逆时针度数 android:toDegrees RotateAnimation(…, float toDegrees, …) 旋转结束角度，正代表顺时针度数，负代表逆时针度数 android:pivotX RotateAnimation(…, float pivotX, …) 缩放起点X坐标，数值，百分比，百分比p，注① android:pivotY RotateAnimation(…, float pivotY) 缩放起点Y坐标，同上规律 AlphaAnimation属性详解： xml属性 java方法 解释 android:fromAlpha AlphaAnimation(float fromAlpha, …) 动画开始的透明度（0.0到1.0，0.0是全透明，1.0是不透明） android:toAlpha AlphaAnimation(…, float toAlpha) 动画结束的透明度，同上 AnimationSet属性详解： AnimationSet继承自Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自Animation，所以特别注意，当我们对set标签使用Animation的属性时会对该标签下的所有子控件都产生影响。譬如我们在set标签下加入duration=“1000”，子控件的duration属性会失效。 1.3 View动画的使用方法及注意事项 上述的使用方法已经非常详细了，也并没有什么难以理解的地方，我们只需要创建相应的xml文件，然后在activity里startAnimation就可以完成动画了。当然了，Animation类和View操作Animation还有一些如下的实用方法： Animation类的方法 解释 reset() 重置Animation的初始化 cancel() 取消Animation动画 start() 开始Animation动画 setAnimationListener() 给当前Animation设置动画监听 hasStarted() 判断当前Animation是否开始 hasEnded() 判断当前Animation是否结束 —————————- —————————- View类对Animation的操作方法 解释 startAnimation(Animation animation) 对当前View开始设置的Animation动画 clearAnimation() 取消当View在执行的Animation动画 注意事项 特别特别注意：补间动画执行之后并未改变View的真实布局属性值。切记这一点，譬如我们在Activity中有一个 Button在屏幕上方，我们设置了平移动画移动到屏幕下方然后保持动画最后执行状态呆在屏幕下方，这时如果点击屏幕下方动画执行之后的Button是没 有任何反应的，而点击原来屏幕上方没有Button的地方却响应的是点击Button的事件。 在进行动画的时候，尽量使用dp，因为px会导致适配问题。 1.4 View动画Interpolator插值器详解 插值器简介 首先，我们先看一下源码的解释： 注释说明：插值器定义了动画的变化，使一些基础的动画如（平移，缩放，旋转，透明）可以被加速，减速，重复等通过上图可以看见其实系统提供给我们的各类型插值器都是实现了Interpolator接口，具体如下： java类 xml 描述 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 动画始末速率较慢，中间加速 AccelerateInterpolator @android:anim/accelerate_interpolator 动画开始速率较慢，之后慢慢加速 AnticipateInterpolator @android:anim/anticipate_interpolator 开始的时候从后向前甩 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 类似上面AnticipateInterpolator BounceInterpolator @android:anim/bounce_interpolator 动画结束时弹起 CycleInterpolator @android:anim/cycle_interpolator 循环播放速率改变为正弦曲线 DecelerateInterpolator @android:anim/decelerate_interpolator 动画开始快然后慢 LinearInterpolator @android:anim/linear_interpolator 动画匀速改变 OvershootInterpolator @android:anim/overshoot_interpolator 向前弹出一定值之后回到原来位置 插值器的使用 插值器的使用比较简答，如下： 12345678910111213&lt;setxmlns:android="http://schemas.android.com/apk/res/android"&lt;!--运动结束时弹起--&gt;android:interpolator="@android:anim/bounce_interpolator"&gt;&lt;!--平移动画标签--&gt;&lt;translate android:fromXDelta="0%p" android:toXDelta="20%p" android:fromYDelta="0%p" android:toYDelta="20%p" android:duration="4000"/&gt;&lt;!--缩放动画标签--&gt;&lt;/set&gt; 我们看一下设置插值器后的效果： 插值器的自定义 当系统提供给我们的插值器不能满足开发需求时，就需要我们自定义，而插值器的自定义有两种方式，一种xml实现，一种java实现。 xml实现方式在anim文件下创建xml文件 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;accelerateInterpolatorxmlns:android="http://schemas.android.com/apk/res/android"android:factor="0.8"&gt;&lt;/accelerateInterpolator&gt; 通过代码我们发现，这种方式只能修改现有插值器的一些属性，但有些插值器不具备修改属性，那么我们就通过java代码实现进一步需求 java代码实现方式通过上面的学习我们知道，所有的插值器都是继承自Interpolator接口，它则继承TimeInterpolator接口，而这个接口定义了float getInterpolation(float input);方法 1234567public class AccelerateDecelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125;&#125; 12345678910111213141516public interface TimeInterpolator &#123;/** * Maps a value representing the elapsed fraction of an animation to a value that represents * the interpolated fraction. This interpolated value is then multiplied by the change in * value of an animation to derive the animated value at the current elapsed animation time. * * @param input A value between 0 and 1.0 indicating our current point * in the animation where 0 represents the start and 1.0 represents * the end * @return The interpolation value. This value can be more than 1.0 for * interpolators which overshoot their targets, or less than 0 for * interpolators that undershoot their targets. */float getInterpolation(float input);&#125; 我们需要继承Interpolator接口并实现getInterpolation();，在方法里处理业务逻辑即可。 2.Drawable Animation（帧动画）2.1帧动画概述帧动画是顺序播放一组预先定义好的图片，不同于View动画，系统提供了另外一个类AnimationDrawable来使用帧动画。 2.2帧动画的使用首先我们找一组帧动画的图片放入drawable-xhdpi文件夹下，其次在drawable文件夹下创建xml文件，如下所示： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/refresh1" android:duration="180"/&gt; &lt;item android:drawable="@drawable/refresh2" android:duration="180"/&gt; ... &lt;item android:drawable="@drawable/refresh25" android:duration="180"/&gt;&lt;/animation-list&gt; 123456789view = findViewById(R.id.view); view.setBackgroundResource(R.drawable.drawable_anim); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AnimationDrawable animationDrawable = (AnimationDrawable) view.getBackground(); animationDrawable.start(); &#125; &#125;); 通过上述代码，帧动画已经完成了，我们来看下效果图： &lt;animation-list&gt; 必须是根节点，包含一个或者多个&lt;item&gt;元素，属性有：android:oneshot true代表只执行一次，false循环执行。&lt;item&gt; 类似一帧的动画资源。 &lt;item&gt; animation-list的子项，包含属性如下：android:drawable 一个frame的Drawable资源。android:duration 一个frame显示多长时间。 帧动画很简单，但容易引起OOM，我在这里也就不多赘述。 3.Property Animation（属性动画）3.1 未完待续…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画(Animation)</tag>
      </tags>
  </entry>
</search>
